# Example: Reentrancy Attack with Multiple Colluding Attackers

In this example a reentrancy issue can only be exploited when the attacker
utilizes two colluding smart contracts to exploit the reentrancy. The victim
employs per-address locking to prevent malicious reentrancy. However, during
the callback the first attacker contract can pass control to a second attacker
contract, which in turn can reenter the victim contract.

* `victim.sol` - Implementation of the vulnerable Bank contract (Figure 2 in
  the paper).
* `attack.efcf` - test case generated by EF/CF
* `attack.efcf.yml` - test case generated by EF/CF converted to human readable
  yaml format.
* `attack.efcf.sol` - attacker contract synthesized base on the test case
  generated by EF/CF.
 
 
To start the fuzzing with EF/CF, we can launch it with:
 
```
efcfuzz --source victim.sol --cores `nproc` --name VulnBankBuggyLockHard --until-crash --quiet --print-progress
``` 

* `--quiet` suppresses the base fuzzer's output (i.e., AFL++'s).
* `--print-progress` will periodically log the current fuzzing stats.
* `--source` the solidity source code.
* `--until-crash` stop after finding first crash.
* `--cores` number of cores to use. adapt it to your liking.

This command instructs EF/CF to fuzz the victim contract
`VulnBankBuggyLockHard` until a crash is discovered. Depending on the machine
this should take a couple of minutes until the first bug, or crash as it called
here, is discovered. EF/CF uses the AFL++ fuzzer to drive the fuzzing process,
so the output directory is very similar to what AFL++ outputs. However, EF/CF
performs several helpful post-processing steps. For example, EF/CF will
automatically minimize crashing test cases. We can run and inspect the
identified crashing test case with:

```
cd ./efcf_out/
./r.sh crashes_min/w5_id:000000,sig:06,src:000276,time:82684,execs:1542787,EM-____e-_____________________-_____-_____-____
```

Using the `efuzzcaseanalyzer` tool (or the `./a.sh` or `./r.sh` wrapper
scripts) we can inspect the generated test case. We can further attempt to
minimize the testcase using the `./m.sh` wrapper script.

These wrapper scripts invoke the `efuzzcase*` utilities. In the docker
container we can also simply call `efuzzcaseanalyzer -a efcf_out/contract.abi
attack.efcf`.

```
Block header:
  number: 0
  difficulty: 0
  gas_limit: 0
  timestamp: 0
  initial_ether: 1

TX[0] with tx_sender[0]; tx_receiver[0]; call_value: 0x1; length: 4; block+=0; #returns=0
  func: deposit() (0xd0e30db0)
  input: {  }
TX[1] with tx_sender[0]; tx_receiver[0]; call_value: 0x0; length: 68; block+=0; #returns=0
  func: addAllowance(address,uint256) (0xf3c40c4b)
  input: { address(0xc4b803ea8bc30894cc4672a9159ca000d377d9a3), uint(115792089237316195423570985008687907853269984665640564039457584007913129639929),  }
TX[2] with tx_sender[0]; tx_receiver[0]; call_value: 0x0; length: 4; block+=0; #returns=1
  func: withdrawBalance() (0x5fd8c710)
  input: {  }
  returns:
    return val: 1; allows reenter: 1; data: 0x
TX[3] with tx_sender[4]; tx_receiver[0]; call_value: 0x0; length: 68; block+=0; #returns=0
  func: transferFrom(address,uint256) (0x1c6adc3)
  input: { address(0xc04689c0c5d48cec7275152b3026b53f6f78d03d), uint(1),  }
TX[4] with tx_sender[4]; tx_receiver[0]; call_value: 0x0; length: 4; block+=0; #returns=0
  func: withdrawBalance() (0x5fd8c710)
  input: {  }
```

All crashing test cases are also automatically converted into Solidity attack contracts in
`./attacks` by the `efcfuzz` utility. The solidity code equivalent to the above
testcase can be found in <a href="./attack.efcf.sol">`./attack.efcf.sol`</a>.
